<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no,viewport-fit=cover"/>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; }
    #ui-container {
      position: relative; /* Add this line */
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .ui-element {
      position: absolute;
      box-sizing: border-box;
      pointer-events: auto;
      border-radius: 0px; /* Default to square */
    }
    .panel {
      background-color: rgba(255, 255, 255, 0.95);
      border: 2px solid #444;
    }
    .button {
      cursor: pointer;
      padding: 10px 20px;
      text-align: center;
      user-select: none;
      font-family: sans-serif;
      font-weight: bold;
      transition: background-color 0.2s ease;
      border-radius: 0px;
    }
  </style>
</head>
<body>
  <div id="ui-container"></div>
  <script>
class UIRenderer {
  constructor() {
    this.uiContainer = document.getElementById('ui-container');
    this.elements = {};
    this.state = {};
    this.externalDefs = {}; // for namespace references
    window.addEventListener('resize', () => this.render(this.currentUI));
  }

  render(uiDefinition, externalDefs = {}) {
    this.uiContainer.innerHTML = '';
    this.currentUI = uiDefinition;
    this.externalDefs = externalDefs;
    this.elements = {};

    for (const [id, def] of Object.entries(uiDefinition)) {
      const el = this.createElement(id, def);
      if (el) this.uiContainer.appendChild(el);
    }
  }

  createElement(id, def) {
    const el = document.createElement('div');
    el.id = id;
    el.className = `ui-element ${def.type || ''}`;
    if (def.size) {
      el.style.width = def.size[0] + 'px';
      el.style.height = def.size[1] + 'px';
    }

    // Calculate the center of the screen
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // Adjust the offset so that (0,0) is the center of the screen
    if (def.offset) {
      const offsetX = def.offset[0] + centerX;
      const offsetY = def.offset[1] + centerY;
      el.style.left = offsetX + 'px';
      el.style.top = offsetY + 'px';
    }

    if (def.visible === false) el.style.display = 'none';

    this.elements[id] = el;

    switch (def.type) {
      case 'panel': this.setupPanel(el, def); break;
      case 'button': this.setupButton(el, def, id); break;
      case 'stack_panel': this.setupStackPanel(el, def); break;
    }

    return el;
  }

  setupPanel(el, def) {
    if (def.color) el.style.backgroundColor = this.parseColor(def.color, def.alpha || 1);
  }

  setupButton(el, def, id) {
    el.textContent = def.text || 'Button';
    el.classList.add('button');

    const controls = this.getControlColors(def.controls);
    el.style.backgroundColor = controls.default;

    let toggled = false;
    let hovered = false;
    let pressed = false;

    el.addEventListener('mouseenter', () => {
      hovered = true;
      this.updateButtonColor(el, { toggled, hovered, pressed }, controls);
    });

    el.addEventListener('mouseleave', () => {
      hovered = false;
      this.updateButtonColor(el, { toggled, hovered, pressed }, controls);
    });

    el.addEventListener('mousedown', () => {
      pressed = true;
      this.updateButtonColor(el, { toggled, hovered, pressed }, controls);
    });

    el.addEventListener('mouseup', () => {
      pressed = false;
      toggled = !toggled;
      this.state[id] = toggled;

      if (def.bindings) {
        def.bindings.forEach(binding => {
          const target = this.elements[binding.binding_name];
          if (target && binding.binding_name_override === '#visible') {
            target.style.display = toggled ? 'block' : 'none';
          }
        });
      }

      this.updateButtonColor(el, { toggled, hovered, pressed }, controls);
    });
  }

  updateButtonColor(el, state, colors) {
    if (state.toggled && state.hovered && colors.checked_hover) {
      el.style.backgroundColor = colors.checked_hover;
    } else if (state.toggled && colors.checked) {
      el.style.backgroundColor = colors.checked;
    } else if (state.pressed && state.hovered && colors.pressed_hover) {
      el.style.backgroundColor = colors.pressed_hover;
    } else if (state.hovered) {
      el.style.backgroundColor = colors.hover;
    } else {
      el.style.backgroundColor = colors.default;
    }
  }

  getControlColors(controls = []) {
    const out = {
      default: '#999',
      hover: '#bbb',
      pressed: '#888',
      pressed_hover: null,
      checked: null,
      checked_hover: null,
    };
    controls.forEach(control => {
      const [key, val] = Object.entries(control)[0];
      if (key === 'default') out.default = val.color;
      if (key === 'default_hover') out.hover = val.color;
      if (key === 'pressed') out.pressed = val.color;
      if (key === 'pressed_hover') out.pressed_hover = val.color;
      if (key === 'checked') out.checked = val.color;
      if (key === 'checked_hover') out.checked_hover = val.color;
    });
    return out;
  }

  parseColor(hex, alpha = 1) {
    if (hex.startsWith('#')) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    return hex;
  }

  setupStackPanel(el, def) {
    const isVertical = def.orientation === 'vertical';
    const spacing = def.contain ? 0 : (
      (isVertical ? def.size[1] : def.size[0]) / def.controls.length
    );

    el.style.display = 'flex';
    el.style.flexDirection = isVertical ? 'column' : 'row';
    el.style.overflow = 'hidden';
    el.style.backgroundColor = this.parseColor(def.color || '#000', def.alpha || 1);

    def.controls.forEach((control, i) => {
      const [id, content] = Object.entries(control)[0];
      let childDef;

      if (id.includes('@')) {
        const [name, path] = id.split('@')[1].split('.');
        childDef = this.externalDefs[name]?.[path];
      } else {
        childDef = content;
      }

      if (!childDef) return;

      const childEl = this.createElement(id, childDef);
      if (def.contain) {
        childEl.style.flex = '0 0 auto';
      } else {
        childEl.style.flex = '1';
      }

      childEl.style.position = 'relative';
      el.appendChild(childEl);
    });
  }
}

const exampleDefs = {
  my_panel1: {
    type: 'panel',
    size: [300, 100],
    offset: [100, 0],
    color: '#1abc9c',
    visible: false,
  },
  my_panel2: {
    type: 'panel',
    size: [300, 100],
    offset: [200, 0],
    color: '#f3a35c',
    visible: false,
  },
  my_panel3: {
    type: 'panel',
    size: [300, 100],
    offset: [300, 0],
    color: '#a73613',
    visible: false,
  },
  my_stack: {
    type: 'stack_panel',
    offset: [0, 0],
    size: [300, 300],
    orientation: 'horizontal',
    contain: true,
    alpha: 1,
    controls: [
      {
        button1: {
          size: [20, 20],
          type: 'button',
          text: 'First',
          bindings: [
            {
              binding_name: 'my_panel1',
              binding_name_override: '#visible'
            }
          ],
          controls: [
            {
              pressed: {
                type: 'panel',
                color: '#1abc9c',
                size: [100, 100],
                offset: [400, 300]
              }
            }
          ]
        }
      },
      {
        button2: {
          size: [40, 20],
          type: 'button',
          text: 'Second',
          bindings: [
            {
              binding_name: 'my_panel2',
              binding_name_override: '#visible'
            }
          ],
          controls: [
            {
              pressed: {
                type: 'panel',
                color: '#f3a35c',
                size: [100, 100],
                offset: [-400, 300]
              }
            }
          ]
        }
      },
      {
        button3: {
          size: [20, 20],
          type: 'button',
          text: 'Third',
          bindings: [
            {
              binding_name: 'my_panel3',
              binding_name_override: '#visible'
            }
          ],
          controls: [
            {
              pressed: {
                type: 'panel',
                color: '#a73613',
                size: [100, 100],
                offset: [0, 300]
              }
            }
          ]
        }
      }
    ]
  }
};


const renderer = new UIRenderer();
renderer.render(exampleDefs);

  </script>
</body>
</html>
